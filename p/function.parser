// =================================
// Copyright (c) 2023 Seppo Laakko
// Distributed under the MIT license
// =================================

export module p.function.parser;

[interface]import p.lexer;
[interface]import p.parsing_context;
[interface]import p.ast;
[interface]import p.subroutine;
[implementation]import p.token;
[implementation]import p.parameter.parser;
[implementation]import p.expression.parser;
[implementation]import p.type.parser;
[implementation]import p.block.parser;
[implementation]import p.procedure.parser;

parser FunctionParser
{
    lexer p::lexer::PLexer<char>;

    using ParameterParser.ParameterList;
    using ExpressionParser.TypeIdentifier;
    using BlockParser.SubroutineBlock;

    FunctionDeclaration(ParsingContext* context, var p::Function* function)
        ::= FunctionHeading(context):functionHeading
            { 
                function = MakeFunction(context, functionHeading, lexer, pos); 
            }
            SEMICOLON 
            SubroutineBlock(context, function):subroutineBlock
            SEMICOLON
            {
                function->ResolveDeclaration(context, lexer, pos); 
            }
        ;

    FunctionHeading(ParsingContext* context, var std::unique_ptr<p::FunctionHeading> heading) : p::FunctionHeading*
        ::= 
        (   FUNCTION 
            FunctionName(context):functionName{ heading.reset(new p::FunctionHeading(context, functionName, lexer, pos)); } 
            ParameterList(context, heading.get()):parameterList 
            COLON 
            ResultType(context):resultType{ heading->SetResultType(resultType); }
        )
        {
            return heading.release();
        }
        ;

    FunctionName(ParsingContext* context, var std::unique_ptr<IdentifierNode> objectId) : p::QualifiedIdNode*
        ::= ID{  objectId.reset(new IdentifierNode(lexer.GetToken(pos).ToString(), IdentifierKind::function, pos)); } 
            DOT ID{ return new QualifiedIdNode(objectId.release(), new IdentifierNode(lexer.GetToken(pos).ToString(), IdentifierKind::function, pos), pos); }
        |   ID{ return new QualifiedIdNode(nullptr, new IdentifierNode(lexer.GetToken(pos).ToString(), IdentifierKind::function, pos), pos); }
        ;

    ResultType(ParsingContext* context) : p::Type*
        ::= TypeIdentifier(context):typeIdentifier{ return context->GetBlock()->GetType(typeIdentifier->Str(), lexer, pos); }
        |   INTEGER{ return context->GetBlock()->GetType("integer", lexer, pos); }
        |   REAL{ return context->GetBlock()->GetType("real", lexer, pos); }
        |   CHAR{ return context->GetBlock()->GetType("char", lexer, pos); }
        |   BOOLEAN{ return context->GetBlock()->GetType("boolean", lexer, pos); }
        |   STRING{ return context->GetBlock()->GetType("string", lexer, pos); }
        |   POINTER{ return context->GetBlock()->GetType("pointer", lexer, pos); }
        ;
}
