// =================================
// Copyright (c) 2023 Seppo Laakko
// Distributed under the MIT license
// =================================

export module p.statement.parser;

[interface]import p.lexer;
[interface]import p.parsing_context;
[interface]import p.ast;
[implementation]import p.token;
[implementation]import p.expression.parser;

parser StatementParser
{
    lexer p::lexer::PLexer<char>;

    using ExpressionParser.VariableReference;
    using ExpressionParser.FunctionIdentifier;
    using ExpressionParser.ArgumentList;
    using ExpressionParser.Expression;
    using ExpressionParser.VariableIdentifier;
    using ExpressionParser.ConstantExpression;

    Statement(ParsingContext* context) : p::StatementNode*
        ::= SimpleStatent(context):simpleStatent{ return simpleStatent; }
        |   StructuredStatement(context):structuredStatement{ return structuredStatement; }
        |   empty{ return new EmptyStatementNode(pos); }
        ;

    SimpleStatent(ParsingContext* context) : p::StatementNode*
        ::= AssignmentStatement(context):assignmentStatement{ return assignmentStatement; }
        |   ProcedureStatement(context):procedureStatement{ return procedureStatement; }
        ;

    AssignmentStatement(ParsingContext* context) : p::StatementNode*
        ::= 
        (
            Expression(context):left
            ASSIGN
            Expression(context):right
        )
        {
            return new p::AssignmentStatementNode(left, right, pos);
        }
        ;

    ProcedureStatement(ParsingContext* context, var std::unique_ptr<StatementNode> node) : p::StatementNode*
        ::= 
        (   ProcedureIdentifier(context):procedureIdentifier{ node.reset(new ProcedureCallStatementNode(procedureIdentifier, pos)); }
            ArgumentList(context, node.get()):argumentList
        |   Expression(context):expression{ node.reset(new ExpressionStatementNode(expression, pos)); }
        )
        {
            return node.release();
        }
        ;

    ProcedureIdentifier(ParsingContext* context) : p::IdentifierNode*
        ::= ID{ IdentifierNode* procedureId = MakeProcedureId(context, lexer.GetToken(pos).ToString(), pos); pass = procedureId != nullptr; if (pass) { return procedureId; }}
        ;

    StructuredStatement(ParsingContext* context) : p::StatementNode*
        ::= CompoundStatement(context):compoundStatement{ return compoundStatement; }
        |   ConditionalStatement(context):conditionalStatement{ return conditionalStatement; }
        |   RepetitiveStatement(context):repetitiveStatement{ return repetitiveStatement; }
        ;

    CompoundStatement(ParsingContext* context, var std::unique_ptr<p::CompoundStatementNode> node) : p::CompoundStatementNode*
        ::= 
        (
            BEGIN{ node.reset(new CompoundStatementNode(pos)); }
            Statement(context):first{ node->AddStatement(first); }
            (   SEMICOLON 
                Statement(context):next{ node->AddStatement(next); }
            )* 
            END
        )
        {
            return node.release();
        }
        ;

    ConditionalStatement(ParsingContext* context) : p::StatementNode*
        ::= IfStatement(context):ifStatement{ return ifStatement; }
        |   CaseStatement(context):caseStatement{ return caseStatement; }
        ;

    IfStatement(ParsingContext* context, var std::unique_ptr<IfStatementNode> node) : p::StatementNode*
        ::= 
        (   IF
            Expression(context):condition
            THEN 
            Statement(context):thenStatement { node.reset(new IfStatementNode(condition, thenStatement, pos)); }
            (   ELSE 
                Statement(context):elseStatement{ node->SetElseStatement(elseStatement); }
            )?
        )
        {
            return node.release();
        }
        ;

    CaseStatement(ParsingContext* context, var std::unique_ptr<CaseStatementNode> node) : p::StatementNode*
        ::= 
        (
            CASE 
            Expression(context):condition{ node.reset(new CaseStatementNode(condition, pos)); }
            OF 
            Case(context):first{ node->AddCase(first); } 
            (
                SEMICOLON 
                Case(context):next{ node->AddCase(next); } 
            )* 
            (
                ElsePart(context):elsePart{ node->SetElsePart(elsePart); }
            )? 
            SEMICOLON? 
            END
        )
        {
            return node.release();
        }
        ;

    Case(ParsingContext* context, var std::unique_ptr<p::CaseNode> node) : p::CaseNode*
        ::= 
        (
            empty{ node.reset(new CaseNode(pos)); }
            ConstantRange(context):first{ node->AddRange(first); } 
            (
                COMMA 
                ConstantRange(context):next{ node->AddRange(next); }
            )* 
            COLON 
            Statement(context):statement{ node->SetStatement(statement); }
        )
        {
            return node.release();
        }
        ;

    ConstantRange(ParsingContext* context, var std::unique_ptr<Node> node) : p::Node*
        ::= 
        (   ConstantExpression(context):rangeStart{ node.reset(rangeStart); }
            (
                (
                    DOTDOT 
                    ConstantExpression(context):rangeEnd{ node.reset(new ConstantRangeNode(node.release(), rangeEnd, pos)); }
                )
                |   empty
                {
                    node.reset(new ConstantRangeNode(node.release(), nullptr, pos));
                }
            )
        )
        {
            return node.release();
        }
        ;

    ElsePart(ParsingContext* context) : p::StatementNode*
        ::= ELSE Statement(context):statement{ return statement; }
        ;

    RepetitiveStatement(ParsingContext* context) : p::StatementNode*
        ::= RepeatStatement(context):repeatStatement{ return repeatStatement; }
        |   WhileStatement(context):whileStatement{ return whileStatement; }
        |   ForStatement(context):forStatement{ return forStatement; }
        ;

    RepeatStatement(ParsingContext* context, var std::unique_ptr<RepeatStatementNode> node) : p::StatementNode*
        ::= 
        (
            REPEAT{ node.reset(new RepeatStatementNode(pos)); }
            Statement(context):first{ node->AddStatement(first); } 
            (   SEMICOLON 
                Statement(context):next{ node->AddStatement(next); } 
            )* 
            UNTIL 
            Expression(context):condition{ node->SetCondition(condition); }
        )
        {
            return node.release();
        }
        ;

    WhileStatement(ParsingContext* context) : p::StatementNode*
        ::= 
        (
            WHILE Expression(context):condition DO Statement(context):statement
        )
        {
            return new WhileStatementNode(condition, statement, pos);
        }
        ;

    Direction : p::Direction
        ::= TO{ return p::Direction::to; }
        |   DOWNTO{ return p::Direction::downto; }
        ;

    ForStatement(ParsingContext* context) : p::StatementNode*
        ::= 
        (
            FOR 
            ControlVariable(context):controlVariable 
            ASSIGN 
            InitialValue(context):initialValue 
            Direction:direction
            FinalValue(context):finalValue 
            DO 
            Statement(context):statement
        )
        {
            return new ForStatementNode(controlVariable, initialValue, direction, finalValue, statement, pos);
        }
        ;

    ControlVariable(ParsingContext* context) : p::IdentifierNode*
        ::= VariableIdentifier(context):variableIdentifier{ return variableIdentifier; }
        ;

    InitialValue(ParsingContext* context) : p::Node*
        ::= Expression(context):expression{ return expression; }
        ;

    FinalValue(ParsingContext* context) : p::Node*
        ::= Expression(context):expression{ return expression; }
        ;
}
