// =================================
// Copyright (c) 2023 Seppo Laakko
// Distributed under the MIT license
// =================================

export module p.unit.parser;

[interface]import p.lexer;
[interface]import p.parsing_context;
[interface]import p.subroutine;
[interface]import p.ast;
[implementation]import p.token;
[implementation]import p.block.parser;
[implementation]import p.program.parser;
[implementation]import p.procedure.parser;
[implementation]import p.function.parser;

parser UnitParser
{
    lexer p::lexer::PLexer<char>;

    using BlockParser.ConstantDeclarationPart;
    using BlockParser.TypeDeclarationPart;
    using BlockParser.VariableDeclarationPart;
    using BlockParser.DeclarationPart;
    using BlockParser.StatementPart;
    using ProgramParser.UsesClause;
    using ProcedureParser.ProcedureHeading;
    using FunctionParser.FunctionHeading;

    Unit(ParsingContext* context)
        ::= UnitHeading(context):unitHeading 
            SEMICOLON 
            InterfacePart(context):interfacePart 
            ImplementationPart(context):implementationPart 
            InitializationPart(context):initializationPart
            DOT{ context->GetModule()->Term(context); }
        ;

    UnitHeading(ParsingContext* context)
        ::= 
        (
            UNIT UnitIdentifier:unitIdentifier
        )
        {
            context->GetModule()->SetKind(ModuleKind::unit);
            context->GetModule()->SetName(unitIdentifier);
            context->GetModule()->SetId();
            context->GetModule()->SetFilePath();
            context->GetModule()->SetSourceFilePath(util::GetFullPath(lexer.FileName()));
            context->GetModule()->Init(context);
        }
        ;

    UnitIdentifier(var std::string unitId) : std::string
        ::= 
        (
            ID{ unitId.append(lexer.GetToken(pos).ToString()); } (DOT ID{ unitId.append(1, '.').append(lexer.GetToken(pos).ToString());})*
        )
        {
            return unitId;
        }
        ;

    InterfacePart(ParsingContext* context)
        ::= INTERFACE{ context->SetModulePart(context->GetModule()->CreateInterfacePart()); }
            UsesClause(context):usesClause? 
            empty
            { 
                context->GetModulePart()->LoadModules(context); 
                Block* block = new Block(context->GetBlock()); 
                block->SetLevel(0);
                context->GetModulePart()->SetBlock(block); 
                context->PushBlock(block); 
                block->ImportModules(context);
            }
            (
                (   ConstantDeclarationPart(context):constantDeclarationPart
                |   TypeDeclarationPart(context):typeDeclarationPart
                |   VariableDeclarationPart(context):variableDeclarationParts
                |   ProcedureAndFunctionHeadingPart(context):procedureAndFunctionHeadingPart
                )*
            )
        ;

    ProcedureAndFunctionHeadingPart(ParsingContext* context, var p::Procedure* procedure, var p::Function* function)
        ::= (   ProcedureHeading(context):procedureHeading{ procedure = MakeProcedure(context, procedureHeading, lexer, pos); procedure->SetAsDeclaration(); }
            |   FunctionHeading(context):functionHeading{ function = MakeFunction(context, functionHeading, lexer, pos); function->SetAsDeclaration(); }
            ) 
            SEMICOLON
        ;

    ImplementationPart(ParsingContext* context)
        ::= IMPLEMENTATION{ context->SetModulePart(context->GetModule()->CreateImplementationPart()); }
            UsesClause(context):usesClause?
            empty
            { 
                context->GetModulePart()->LoadModules(context); 
                Block* block = new Block(context->GetBlock()); 
                block->SetLevel(0);
                context->GetModulePart()->SetBlock(block); 
                context->PushBlock(block); 
                block->ImportModules(context);
                GenerateImplementationIds(context, lexer, pos);
            }
            DeclarationPart(context):declarationPart
            {
                GenerateDefaultImplementations(context, lexer, pos);
            }
        ;

    InitializationPart(ParsingContext* context)
        ::= empty{ context->PushFlags(Flags::initializationPart); }
        (   END
        |   StatementPart(context):statementPart
        )
        {
            context->PopFlags();
            context->PopBlock();
            context->PopBlock();
        }
        ;
}
